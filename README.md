# ErrorCodeFinder

Windows 错误代码查询工具

## 介绍

这个工具用于查询错误代码的名称和对应的解释，支持从名称、代码、类型查找。

![界面截图](https://raw.githubusercontent.com/killtimer0/ErrorCodeFinder/master/img/1.png)

错误代码包含Win32，HRESULT，NTSTATUS，HTTP状态码，WinHTTP，蓝屏代码，DirectX，Gdiplus，errno等共9000+项。工具的特点有：

* 虚表加载，启动速度较快

* 关键字高亮，双色显示

* 支持从自定义模块加载字符串和消息表

* 支持导出功能

* 支持多语言（指自行修改资源段

## 用法

搜索框支持以下格式：

* 错误代码，纯数字/0x开头/h结尾，如`1411`，`0xC0000005`，`0C6h`

* 错误类型，前面加冒号，如`:errno`，`:Win32`

* 错误名称，支持通配符，如`ACCESS`，`D2DERR_*DEVICE`

* 可以用空格分隔多个条件

![使用示例](https://raw.githubusercontent.com/killtimer0/ErrorCodeFinder/master/img/2.gif)

## 下载

在右侧[Release](releases/)中下载对应平台的版本。

## 关于代码

这些代码是之前写的，当时很好奇Win32中虚表的实现，再加上errlook个人感觉并不好用，然后就写了这么一个工具。代码是用vscode写的，vc7工具链编译，当时只是写出来自己用，可能很多语法细节没注意到。这几天把它们整理了以下，创建了一个vs2022工程，导致一大堆警告，这个应该与源码注解（sal.h）缺失有关系。因为当时用vscode写的时候编译并没有sal警告，加上Win32的自绘确实十分复杂，要处理一堆情况，然后屎山就这么堆起来了。最后结果就是代码很凌乱，耦合性也比较高。不过最后终于是能用了，而且我最近收集了更全面的数据，打算重构这个工具（这个下面细说），那这个版本就先这样吧。

然后列举一下代码的结构：

* `dlgmain.c`：这个是主界面的对话框，实现了主界面（除了列表框）的所有逻辑，`ErrorCodeSet *pecs;`这个变量保存了已注册的所有错误代码模块。其他`dlg*.c`是其他对话框的实现。

* `errh.c`：处理程序出现的bug，当错误发生时，`BugHandler`会捕获它并汇报，同时把现场保存到同目录的dump文件中。

* `guiaux.c`：一些常用的GUI操作的封装。

* `utils.c`：工具类，条件搜索就是在这个文件中实现的。

* `ldmgr.c`：里面子类化了一个`SysListView32`，写这个工具的大部分时间都用在这个上面了。关于这个关键字高亮，实现起来比我想象的要难得多：由于有多种字体，程序在收到DPI变化的信息时，要重新创建这些字体；由于字体改变导致列表框默认的宽度测量失效，当列表项省略号折叠时，为了迎合默认行为（鼠标悬停或者键盘定位到折叠项时会展开文字），必须自己实现原地气泡提示（In-place tooltips）；双击表头分隔条的行为（拓宽列使可见的所有项都不折叠）也要自己测量文本大小……

* `provider.c`：注册所有错误代码模块，并提供这些模块会用到的一些函数。

* `mod/ec_*.c`：错误代码模块，每个文件对应一种错误代码类型。

最近从Windows SDK、WDK和MSDN中收集了更多有用的信息，有时间可能会写一个更好用的版本，目前有一点想法~~大饼~~，工具写完大概是这样的：

* 支持搜索常量、枚举类型和它们的对应值和解释。

* 支持搜索COM接口的GUID值、继承关系、方法和它在虚函数表中的索引。

* 支持搜索结构体、联合类型的成员，并提供它们在x86/x64/ARM/ARM64结构体中的偏移量。对于少量宏条件控制的复杂结构体，目前还没有什么好的办法处理，暂时选择了最长的一条分支。

* 支持搜索宏和函数，包括与函数关联的静态库（.lib）和动态库(.dll)。

* 上面那些类型会尽量提供MSDN在线文档的对应链接。

* 考虑到用纯Win32写界面确实很蛋疼，准备用现在比较流行的前端框架写，在浏览器上运行，这样可以不用考虑GUI中那些琐碎的事情，而且可以跨平台。

* 不太想弄后端，准备用wasm保证数据在前端查询的效率。工具的数据量可能比较大，目前想的是把数据包LZMA压缩，下载时保存到IndexDB，并在wasm里面解压。

至于这个可不可行还有待进一步研究。不过有一些想象中的功能放到浏览器中应该是实现不了了，比如从ProgID查CLSID、IDispatch接口查询等等。所以用MFC或者WTL也是一个选择？目前还没有想到什么双赢的办法，先走一步看一步吧。